[{"categories":["技术"],"content":"1.系统环境 CentOS Linux release 8.2.2004 (Core) ","date":"2023-03-15","objectID":"/hugo/:0:1","tags":["hugo"],"title":"使用Hugo搭建博客","uri":"/hugo/"},{"categories":["技术"],"content":"2.安装Golang ver\u003e1.18, 用来编译hugo Golang安装教程 安装后设置go proxy vim ~/.profile # 配置 GOPROXY 环境变量 export GOPROXY=https://proxy.golang.com.cn,direct # 还可以设置不走 proxy 的私有仓库或组，多个用逗号相隔（可选） export GOPRIVATE=git.mycompany.com,github.com/my/private source ~/.profile ","date":"2023-03-15","objectID":"/hugo/:0:2","tags":["hugo"],"title":"使用Hugo搭建博客","uri":"/hugo/"},{"categories":["技术"],"content":"3.安装Hugo 安装gcc yum install -y gcc-c++ 编译hugo go install -tags extended github.com/gohugoio/hugo@latest hugo version 至此hugo安装完成 ","date":"2023-03-15","objectID":"/hugo/:0:3","tags":["hugo"],"title":"使用Hugo搭建博客","uri":"/hugo/"},{"categories":["技术"],"content":"4.安装主题 创建站点 hugo new site quickstart 添加主题 cd quickstart git init git submodule add https://github.com/dillonzq/LoveIt themes/LoveIt echo \"theme = 'LoveIt'\" \u003e\u003e config.toml ","date":"2023-03-15","objectID":"/hugo/:0:4","tags":["hugo"],"title":"使用Hugo搭建博客","uri":"/hugo/"},{"categories":["技术"],"content":"4.运行网站 新建about页面 新建blog //about页面 hugo new about.md //blog hugo new posts/first.md 启动网站, 在网站根目录执行后台运行命令 nohup hugo server -b \"http://你自己的公网ip:80\" -p 80 --bind \"0.0.0.0\" -D \u0026 b http://ip:8080是由于其他人访问的时候，静态资源默认是localhost，所以需要指向自己ip地址和默认端口。 p 8080默认端口1313，指定端口8080 -bind \"0.0.0.0\"，默认启动只允许本机访问，所以需要bind所有机器都可以访问。 在管理后台设置开放端口80 在浏览器输入,查看网站效果 http://ip:80 ","date":"2023-03-15","objectID":"/hugo/:0:5","tags":["hugo"],"title":"使用Hugo搭建博客","uri":"/hugo/"},{"categories":["技术"],"content":"5.主题优化 5.1 设置icp备案 5.2 设置访问统计 ","date":"2023-03-15","objectID":"/hugo/:0:6","tags":["hugo"],"title":"使用Hugo搭建博客","uri":"/hugo/"},{"categories":["探索"],"content":"1. 活了3000年的橄榄树 Magic Gardens 这个树出生的年代是公元前77年。 东方处于西汉元凤四年，汉遣傅介子到楼兰，刺杀楼兰王安归，立其弟尉屠耆为王，尉屠耆更名鄯善国，并将首都由罗布泊西岸迁往南岸的伊循城，向汉朝称臣，原都城楼兰古城则由汉朝派兵屯田。 西方处于罗马共和国末期，盖乌斯·尤利乌斯·恺撒[2]（拉丁语：Gaius Iulius Caesar[2]；前100年7月12日－前44年3月15日），或译儒略·恺撒，史称恺撒大帝或罗马共和国的独裁者[3]，罗马共和国末期的军事统帅、政治家，是罗马共和国体制转向罗马帝国的关键人物 这个是一颗希腊橄榄树，距今仍在出产橄榄油。商家怎么还不推出高端品牌，广告词我都想好了，与凯撒大帝共享这份芬芳。 ","date":"2023-03-05","objectID":"/curious_1/:0:1","tags":["摸鱼1"],"title":"好奇日志第1期","uri":"/curious_1/"},{"categories":["探索"],"content":"2.五十岁转开发成功 作者加拿大华人，从事数据库工作多年，长期奋斗在摸鱼前线，已经50岁了，突然嫌钱少了，奋斗一把居然能面试成功了。 年薪加元从80K涨到base155K+RSU220K(4*25%)+sign-on20K+relocation10K 北美竞争压力真是小 ","date":"2023-03-05","objectID":"/curious_1/:0:2","tags":["摸鱼1"],"title":"好奇日志第1期","uri":"/curious_1/"},{"categories":["探索"],"content":"3.AI辅助写代码工具tabnine 作者个人简介 这个工具感觉用途不算特别大,如果网络不稳定还经常无效, 对我来说goland自身的辅助功能已经足够. 作者还开发过一系列小游戏，特别有意思,画面特别简介，玩法特别有特效，还附带了很好玩的AI 游戏 作者很有商业头脑，游戏通关方法放在油管上 ","date":"2023-03-05","objectID":"/curious_1/:0:3","tags":["摸鱼1"],"title":"好奇日志第1期","uri":"/curious_1/"},{"categories":["探索"],"content":"4.聊聊我通过iOS APP赚到百万+睡后收入的一段经历 现在靠开发APP还可以发家致富,作者靠打包图集，打包电子书，达到了年入百万的睡后收入。 这个路子有开发门槛，起码比抖音蓝海的多,感觉我错过了好几个亿。马上去看了mac mini 价格，准备搞起来。 ","date":"2023-03-05","objectID":"/curious_1/:0:4","tags":["摸鱼1"],"title":"好奇日志第1期","uri":"/curious_1/"},{"categories":null,"content":"简介 ","date":"2023-03-02","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"在深圳工作多年的游戏服务器程序员, 目前在迷你玩 ","date":"2023-03-02","objectID":"/about/:0:1","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"微信: bookheart ","date":"2023-03-02","objectID":"/about/:0:2","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"技术栈 ","date":"2023-03-02","objectID":"/about/:0:3","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Golang, C++, mysql, redis, mongo ","date":"2023-03-02","objectID":"/about/:0:4","tags":null,"title":"About","uri":"/about/"},{"categories":["technology"],"content":" 错误与异常 在golang中错误与异常处理是区分很清晰的 错误：在预期内的非正常行为，开发人员可以对错误进行捕获和处理, 人为恢复错误 异常：非预期内的非正常行为，无法控制的错误，环境问题，栈溢出，goroutine异常等待，程序进入崩溃 Golang处理错误范式, 第一个返回值为正常值，第二返回值为错误，当error为nil时候，第一个返回值才可正常使用。 func DoSomething() (int, error) { } Golang捕获异常,如果不捕获程序就崩溃掉 func DoSomething() (int, error) { //直接制造一个异常 panic(\"make panic) } func main() { defer func() { //使用recover捕获异常, 让程序继续往后执行 if recover() != nil { fmt.Println(\"cache panic\") } DoSomething() } Go的error 接口 这个契约非常简单，支持返回一个字符串即可 type error interface{ Error() string } 错误处理方式 当函数返回了错误类型，我们要对错误类型进行不同处理，比如说最基础的打印日志 处理方式1 Sentinel Error 这种方式最直观，预先定义一系列已知的错误类型，逐个判断属于那个错误即可 //获取到了一个错误 _, err := DoSomething() //错误与已知类型比较, 这个ErrSomething 是已经定义好的错误类型比如io.EOF，syscal.ENOENT if err == ErrSomething { } 特征：这样做的话, Sentinel Error会成为API公共部分，增加了API的表面积。引入了依赖问题 结论:避免Sentinel Error 处理方式2 Error types 把错误的type断言出来,使用switch case 分类 //自定义一个错误 type MyError struct { Msg string File string Line int } func (e *MyError) Error() string { return fmt.Sprintf(\"%v:%v:%v\", e.File, e.Line, e.Msg) } //获取一个自定义错误 func createError() error { return \u0026MyError{\"something happened\", \"main.go\", 10} } //main函数中通过断言应用 func main() { err := createError() //关键操作，获取error接口的具体类型 switch err := err.(type) { case nil: case *MyError: //这里拿到了自定义的类型，可以进行更灵活操作，而不是限定于只能使用error接口的Error fmt.Println(\"get MyEroro type, line:%v\", err.Line) default: } } 特征： 因为要使用类型断言，所有自定义的error类型必须变成public的。引入了依赖问题 结论：避免作为公共API使用 处理方式3 Opaque errors 不透明错误处理, 不解析错误的具体类型，根据行为接口来处理 Assert errors for behaviour, not type //自定义的错误类型的MyError, 添加一个行为接口Temporary package other import \"fmt\" type MyError struct { Msg string } func (e *MyError) Error() string { return fmt.Sprintf(\"msg:%v\", e.Msg) } //实现一个特别的接口 func (e *MyError) Temporary() bool { return true } 创建MyError的函数 func CreateMyError() error { return \u0026MyError{Msg: \"something\"} } main中使用 import ( \"err/other\" \"fmt\" \"io\" ) // 定义一个接口,定义一个函数Temporary跟MyError一样 type MyTemporary interface { Temporary() bool } func main() { //err1 内部实现了Temporary()满足了MyTemporary接口 err1 := other.CreateMyError() te, ok := err1.(MyTemporary) fmt.Printf(\"err1 has Temporary:%v, Temporary():%v\\n\", ok,te.Temporary()) //err2 不满足MyTemporary接口 err2 := io.EOF _, ok2 := err2.(MyTemporary) fmt.Printf(\"err2 has Temporary:%v\\n\", ok2) } output: err1 has Temporary:true, Temporary():true err2 has Temporary:false 特点：在main中本地定义了MyTemporary接口，可以用来判断MyError中是否定义了Tempporary(), 这避免了依赖. main中也不关系错误具体是什么类型，只关心行为 ","date":"2021-08-16","objectID":"/error/:0:0","tags":["golang"],"title":"Golang的错误处理","uri":"/error/"},{"categories":["technology"],"content":"Handing Error Indented flow is for errors 代码规范，处理错误的代码缩进 比如 if err != nil { //handler error 处理错误缩进 } //do stuff 正常代码不缩进 不规范展示 if err == nil { // do stuff } //handle error Eliminate error handing by elimination errors 处理错误的不正确方式，消除处理的方式来消除错误，跟杀掉花刺子信使的方式来处理坏消息一样 func AuthenticateRequest(r *Request) error { return authenticate(r.User) } 直接把错误上抛，导致上层处理不了错误，底层返回了一个找不到文件错误，调用层就很莫名其妙，起码要告诉我是什么文件，或者那行代码错误吧。 产生了错误，但是没用添加足够的信息返回上层，那么这个错误就没意义。 正确姿势，应该使用errors.Wrap添加信息返回去, 返回结果可以通过errors.Cause取原生错误，也可以取调用堆栈 func ReadFile(path string) error { f, err := os.Open(path) if err != nil { //在原有错误情况下，添加一点信息\"open failed\",再返回出去 return errors.Wrap(err, \"open failed\") } defer f.Close() return nil } func main() { err := ReadFile(\"aa\") if err != nil { //显示添加的信息和原错误信息 fmt.Println(err) //显示原生错误类型和信息 fmt.Printf(\"origin error: type:%T, value:%v\\n\", errors.Cause(err), errors.Cause(err)) //打印堆栈 fmt.Printf(\"stack %+v\\n\", err) } } //output open failed: open aa: The system cannot find the file specified. origin error: type:*os.PathError, value:open aa: The system cannot find the file specified. stack open aa: The system cannot find the file specified. open failed main.ReadFile E:/test/main.go:30 main.main E:/test/main.go:13 runtime.main C:/Program Files/Go/src/runtime/proc.go:204 runtime.goexit C:/Program Files/Go/src/runtime/asm_amd64.s:1374 errors.WithMessage功能类似errors.Wrap, 但是不能打印调用堆栈 func ReadFile2(path string) error { f, err := os.Open(path) if err != nil { return errors.WithMessage(err, \"some message\") } defer f.Close() return nil } func main() { err = ReadFile2(\"bb\") if err != nil { fmt.Println(err) fmt.Printf(\"origin error: type:%T, value:%v\\n\", errors.Cause(err), errors.Cause(err)) //打印了也没有调用堆栈 fmt.Printf(\"stack %+v\\n\", err) } } //output some message: open bb: The system cannot find the file specified. origin error: type:*os.PathError, value:open bb: The system cannot find the file specified. stack open bb: The system cannot find the file specified. some message 不在每个错误产生的地方导出打印日志 通过使用errors.Wrap把本地错误信息添加，在最上层调用是%+v打印堆栈详情 错误处理总结：.当函数调用产生了错误，要么本地处理掉错误，返回降级数据，要么添加上下文信息，通过wrap返回给调用方 错误包装和拆包 上述的errors.wrap就是一个go官方定义的错误包装，通过Cause进行拆包，这也可以自定义包装和拆包 在自定义错误类型实现Unwrap接口，就可以使用errors的Is和As函数 func main() { err := CreateQueryError() //Is依赖于QueryError实现了Unwrap函数 if errors.Is(err, io.ErrClosedPipe) { fmt.Println(\"Is\") } var e *QueryError if errors.As(err, \u0026e) { fmt.Println(\"As\") } } func CreateQueryError() error { return \u0026QueryError{ Query: \"select * from user\", Err: io.ErrClosedPipe, } } type QueryError struct { Query string Err error } func (e *QueryError) Error() string { return \"QueryError\" } func (e *QueryError) Unwrap() error { return e.Err } //output Is As 前面这种要自定义一个错误类型进行wrap， 还有一种更快捷的方式使用%w, 返回的error带了Unwrap方法，返回%w的参数 if err != nil { // Return an error which unwraps to err. return fmt.Errorf(\"decompress %v: %w\", name, err) } 同样支持error.Is, error.As err := fmt.Errorf(\"access denied: %w\", ErrPermission) ... if errors.Is(err, ErrPermission) ... ","date":"2021-08-16","objectID":"/error/:0:1","tags":["golang"],"title":"Golang的错误处理","uri":"/error/"},{"categories":["technology"],"content":" 堆和栈的定义 这是内存中最基本的两个定义， 堆和栈都是存放数据，区别是堆是全局范围可以使用，在整个程序生命周期内有效。栈的有效范围和生命周期比较小，一般仅限于函数的作用范围。 C++中栈和堆从语法上明确定义的，栈是明确通过new来定义的，堆的数据不会跑到栈，但是Go的栈不需要明确new定义，堆内的数据也可能逃逸到堆上。Go设计者明显更注重开发效率 C++中栈上分配的内存，开发人员必须自己负责回收， Go存在Runtime GC来处理 栈： 栈区的内存一般有编译器自动进行释放和分配，随着函数创建而创建， 函数的返回而销毁。 函数可以直接访问栈内的内存，间接访问栈外内存 堆： 堆上分配由编译器和开发人员共同进行，堆上数据释放通过GC处理。在Go中只要变量被分享到函数作用域之外，那么就整个变量就会在栈上分配。 堆分配需要一块足够大的内存 从分配和回收来考虑，栈比堆都更消耗性能，所有stack allocation is cheap and heap allocation is expensive Go编译器在函数内的变量分配到栈中，如果在函数返回后无法证明变量未被引用，则分配到对堆上。 从程序运行正确角度看， Go中变量存储位置是堆还是栈与语法无关，都能正确运行。 但是从程序高性能角度看，如果局部变量很大，应该放在堆上避免频繁创建和回收， 函数返回时候尽量少返回指针，大部分变量都应该在栈内，函数退出直接回收。 逃逸分析 检查变量作用域超出所在栈 go build-gcflags '-m' 逃逸案例 1 函数返回值是指针 func main() { num := getRandom() println(*num) } func getRandom() *int { tmp := rand.Intn(100) return \u0026tmp } 为什么会发生逃逸， 在getRandom中tmp如果是在分配在栈中，那么函数调用完后，tmp指向的内存就回收掉了，main函数中拿到的就是tmp指向的就是无效的内存地址。如果是C++中这种情况就是野指针，直接崩掉。 Go中就友好的多，编译器避免出现无效的内存地址，就直接把tmp的内存分配在堆中，getRandom回收掉不影响, main函数也能正常访问tmp的内存地址。 2 引用类型对象赋值 A = B 如果A是引用数据类型会导致逃逸, Go中引用类型数据由 func, interface{}, slice, map, chan, *Type 3 for循环外声明，循环内分配 4 指针或带指针的值发生到channel中 5 在slice中存储指针或带指针的值 6 slice重新分配 7 在interface类型上调用方法 分段栈(Segmented stacks) Go v1.0-1.2 Go应用程序运行时， 每个goroutine都维护一个自己的栈区，自己的栈区不能被其他goroutine使用，v1.4后最小栈区内存降低到2KB, 栈区最大值64位系统默认是1G 分段栈实现：在扩容的时候分配一块新的内存并链接到老的栈内存块 ，新旧两块内存是分开的，所有叫分段栈 “hot split”: 如果在栈快满的情况下，下一次函数调用就触发栈扩容， 函数返回时候新分配的\"stack chunk\"会被清理掉，如果这个情况刚好发生在循环中，就会导致频繁alloc/free，严重影响性能 Gov1.2采用把最低栈默认改成8KB降低触发热分裂问题发生概率 连续栈（Contiguous status）Go v1.3-1.4 为了解决上述的热分裂问题，使用连续栈。当触发栈扩容的时候，分配一个原来两倍大的内存块，并把老的内存块内容复制到新的内存块。思路与slice，c++的vector扩容相似 那么栈区空间有扩容就有收缩， 如果使用率不超过1/4，垃圾回收时候进行栈缩容 内存管理 内存碎片 随着内存不断申请和释放， 内存上会存在大量碎片， 需要将2个连续未使用的内存块合并，减少碎片 这是因为不同大小的变量分配一块连续的内存 解决方法: Slab-Allactor 将相同规格的变量分配在一起，减少碎片产生和方便碎片回收, 类似的思路在Kernal, Memcache 都可以见 大锁 同一进程下的所有线程共享相同的内存空间，它们申请内存时候需要加锁 内存布局 page 内存页，一块8K大小的内存空间。Go与操作系统之间的内存申请和释放，都是以page为单位的 span 内存块，一个或者多个连续的page组成一个span object 对象， 用来存储一个变量的内存空间 sizeclass 空间规格， 每个span带一个sizeclass, 标记span的page应该如何使用, 通过sizeclass标记本span的page是通过什么规格进行切割，每一个切割内容的数量就是一个object 比如说按32Byte划分一个span, 用来存储16~32Byte的变量 不同span的szieclass下能装的ojbect数量 蓝色图例：sizeclass=K，格子数 64 绿色图例：sizeclass=K+1，格子数 16 蓝色图例：sizeclass=K+2，格子数 8 Go runtime的内存模型 在Go调度模型中P绑定一个本地缓存mcache, 当需要进行内存分配时候，当前的goroutine从mcache中查找可以用的mspan, 因为是本地专用内存，所以不需要加锁. 每个mspan代表一类规格大小，总共重8b到32k类mspan 小于32kb内存分配 mcentral 优先从本地mcache分配内存，每次都那一个mspan， 如果本地没有对口的sizeclass就从其他地方拿， 那么拿？ Go为每个sizeclass的mspan维护者一个mcentral mcentral 内部有两个双向链表，分别表示空闲的mspan和占用的mspan 申请内存过程： mcache已经没有空闲mspan, 那么工作线程去mcentral里申请 获取： 加锁，从mcentral的nonempty链表中找到一个可用的mspan，并将其从链表中删除，取出的mspan放入mcache的empty链表， 将mspan给工作线程来用，解锁 当mcentral没有空闲的mspan时候，会向mheap申请， mheap没有资源就向系统申请新内存。 申请路径: mcache -\u003e mcentral -\u003e mheap 大于32kb内存 超过32kb的内存申请，直接从堆上分配对应数量的内存页（每页8K） 内存分配组成图 总结 内存管理组件 mcache 管理线程本地缓存的mspan mcentral 管理全局的mspan 给所以线程 mheap 从系统分配内存， 大对象也直接从这里分配 mspan 基本单元， 每种类型分配特定大小object ","date":"2021-07-29","objectID":"/memory/:0:0","tags":["golang"],"title":"Go内存原理","uri":"/memory/"},{"categories":["technology"],"content":"GC原理 Garbage Collection C, C++等早期编程语言需要工程师手动管理内存，工程师管理等当，内存管理效率很高，但是这样就影响了开发效率。 后续出来的编程语言php,java,golang都出现了垃圾回收机制，语言内部进行统一管理内存分配和释放。 主流GC算法 引用计数 追踪式垃圾回收, Golang使用的三色标记法属于这种算法实现的一种 Mark\u0026Sweep 标记清除法 在三色标记法之前，使用的一种算法 过程 STW(stop the world), 停止运转避免引用关系变化，这是GC算法的优化重点 从Root对象开始追踪其他存活对象，进行标记 (Root根对象，可以直接访问的对象，比如全局对象，栈对象中的数据。通过Root对象追踪其他存活的对象) 对堆对象进行迭代，已经标记的对象置位，未标记对象加入freelist, 可用于再分配 Start the World 最种朴素版本的在进行Mark或者Sweep时候都需要完全暂停,所以暂停时间太长 通过Root追踪并标记存活的对象 三色标记法 三色标记法，缩短了暂停时间 简单过程 所有对象默认标记为白色 根对象标记为灰色 从灰色追踪到的对象标记为灰色，原来的灰色标记为黑色，重复进行本步骤，直到没有灰色对象为止 删除白色标记 为什么比Mark\u0026Sweep有更短的暂停时间？ 仅需要在标记前后需要STW,使用了写屏障 GC触发条件 GC Percentage配置选项，默认配置100，（比如当前使用heap内存5M, 当内存扩展了100%为10M时触发GC） 超过2分钟没有触发GC ","date":"2021-07-29","objectID":"/memory/:0:1","tags":["golang"],"title":"Go内存原理","uri":"/memory/"},{"categories":["technology"],"content":"为什么叫SingleFlight 字面直译是单飞，举例：学校宿舍里一群同学要下载同一份资料，每个人都自己进行下载，导致网络很卡每个人都要等很久 这时候，班长说，你们不用下载了，我一个人下载好了再发给你们。这样就节约了大家的时间和网络资源。 ","date":"0001-01-01","objectID":"/singleflight/:0:1","tags":["golang"],"title":"SingleFlight代码阅读和使用","uri":"/singleflight/"},{"categories":["technology"],"content":"SingleFlight 使用场景 把上述的同学下载资料替换成客户端请求服务器资源，就明白了使用场景，对服务器来说短时间内来了大量相同的客户端请求，每条请求都单独处理太消耗服务器资源，容易造成宕机事故。SingleFlight把多个相同请求合并到一起，服务器只处理一个请求即可，大大提高的服务器的效率 源码阅读意外收获 错误处理 普通的错误和panic错误，分别处理，panic的错误打印调用堆栈 解锁操作并没有无脑的使用defer unlock, 而是尽快解锁，避免一切无谓处理 对panic部分还不了解，实际测试效果也没有区别 if e, ok := c.err.(*panicError); ok { // In order to prevent the waiting channels from being blocked forever, // needs to ensure that this panic cannot be recovered. if len(c.chans) \u003e 0 { //迷之代码, 不使用go也不使用select{}也没有效果区别 go panic(e) select {} // Keep this goroutine around so that it will appear in the crash dump. } else { panic(e) } } 全部源码阅读开始 // Package singleflight provides a duplicate function call suppression // mechanism. 重复函数调用抑制机制，(singleflight真正的含义) package singleflight // import \"golang.org/x/sync/singleflight\" import ( \"bytes\" \"errors\" \"fmt\" \"runtime\" \"runtime/debug\" \"sync\" ) // errGoexit indicates the runtime.Goexit was called in // the user given function. // 定义goroutine退出错误 var errGoexit = errors.New(\"runtime.Goexit was called\") // A panicError is an arbitrary value recovered from a panic // with the stack trace during the execution of given function. // 定义一个panic错误，包含调用堆栈信息 type panicError struct { value interface{} stack []byte } // Error implements error interface. // 调用堆栈格式化 func (p *panicError) Error() string { return fmt.Sprintf(\"%v\\n\\n%s\", p.value, p.stack) } // 定义创建panicError方法，放置初始化处理 func newPanicError(v interface{}) error { // 获取堆栈信息 stack := debug.Stack() // The first line of the stack trace is of the form \"goroutine N [status]:\" // but by the time the panic reaches Do the goroutine may no longer exist // and its status will have changed. Trim out the misleading line. // 因为如果panic时候，goroutine已经不存在，第一行堆栈信息已经失效, 删除这行信息 if line := bytes.IndexByte(stack[:], '\\n'); line \u003e= 0 { // 找出第一行结尾，删除 stack = stack[line+1:] } return \u0026panicError{value: v, stack: stack} } // call is an in-flight or completed singleflight.Do call type call struct { //同类的调用每个是独立的goroutine, 这里使用WaitGroup统一管理 wg sync.WaitGroup // These fields are written once before the WaitGroup is done // and are only read after the WaitGroup is done. val interface{} err error // forgotten indicates whether Forget was called with this call's key // while the call was still in flight. //用于标记调用在进行中的时候，发生了取消调用行为 forgotten bool // These fields are read and written with the singleflight // mutex held before the WaitGroup is done, and are read but // not written after the WaitGroup is done. //标记该类请求次数 dups int //存放处理结果 chans []chan\u003c- Result } // Group represents a class of work and forms a namespace in // which units of work can be executed with duplicate suppression. //Group 抽象了一类工作任务，并存储了被抑制了的运行任务 type Group struct { mu sync.Mutex // protects m //操作m的锁 m map[string]*call // lazily initialized //使用时候才开始初始化 } // Result holds the results of Do, so they can be passed // on a channel. //定义返回结果数据格式 type Result struct { Val interface{} Err error Shared bool } // Do executes and returns the results of the given function, making // sure that only one execution is in-flight for a given key at a // time. If a duplicate comes in, the duplicate caller waits for the // original to complete and receives the same results. // The return value shared indicates whether v was given to multiple callers. // 单飞启动入口，给定的key表示一类请求，当key相同的重复调用发生，重复调用回阻塞，等第一个飞行中(in-flight)的操作返回后，一起返回相同结果 func (g *Group) Do(key string, fn func() (interface{}, error)) (v interface{}, err error, shared bool) { //并发安全加锁 g.mu.Lock() if g.m == nil { g.m = make(map[string]*call) } if c, ok := g.m[key]; ok { c.dups++ //只锁最小范围 g.mu.Unlock() //阻塞调用者的goroutine c.wg.Wait() //处理错误， 这个是用断言来判断自定义的错误类型 if e, ok := c.err.(*panicError); ok { panic(e) } else if c.err == errGoexit { //当前goroutine运行终止 runtime.Goexit() } return c.val, c.err, true } c := new(call) c.wg.Add(1) g.m[key] = c g.mu.Unlock() g.doCall(c, key, fn) return c.val, c.err, c.dups \u003e 0 } // DoChan is like Do but returns a channel that will receive the // results when they are ready. // // The ret","date":"0001-01-01","objectID":"/singleflight/:0:2","tags":["golang"],"title":"SingleFlight代码阅读和使用","uri":"/singleflight/"}]